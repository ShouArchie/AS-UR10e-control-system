Nuclear Reactor Monitoring and Response System - C++ Architecture

I. Overview
    A. Purpose: To monitor critical parameters (e.g., temperature at weld points) in a nuclear reactor, detect anomalies, dispatch an autonomous rover for inspection/repair (including on-rover object detection capabilities), provide a user interface for monitoring and control, and log all significant events.
    B. Core Language: C++ ( leveraging C++17 or newer for modern features).
    C. Key Architectural Principles:
        1. Modularity: System components are distinct, independently testable modules with clear interfaces.
        2. Safety-Critical Design: Emphasize robust error handling, fail-safes, input validation, and predictable behavior.
        3. Real-time Performance: For sensor data processing, alert handling, and rover control.
        4. Robustness & Reliability: Through comprehensive error management and resilient communication.
        5. Clear Interfaces: Well-defined APIs for inter-subsystem communication.

II. Main System Components & C++ Implementation Details

    A. Temperature Monitoring Subsystem (TMS)
        1. Purpose: Independently monitors temperatures from fiber optic probes at critical weld points and sends alerts to the Main Control System upon threshold breaches.
        2. Core C++ Components:
            - `ProbeManager` (Class):
                - Manages a collection of `FiberOpticProbe` objects.
                - Responsible for initializing probes (e.g., from a configuration file specifying ID, location, thresholds).
                - Periodically polls probes for temperature readings.
                - `std::vector<FiberOpticProbe> probes;`
                - `void initializeProbes(const std::string& configFile);`
                - `void checkForAlerts();`
            - `FiberOpticProbe` (Class):
                - Represents a single fiber optic temperature probe.
                - Stores unique ID, mapped location, and temperature thresholds.
                - `std::string probeId;`
                - `Location probeLocation;` // struct Location { double x, y, z; };
                - `TemperatureThresholds thresholds;` // struct TemperatureThresholds { double min, max; };
                - `double readTemperature();` // Simulates or interfaces with actual hardware driver.
                - `bool isTemperatureAnomalous(double temp) const;`
                - `AlertData generateAlertData(double currentTemp) const;` // struct AlertData { std::string probeId; Location location; double temp; time_t timestamp; };
            - `TMSCommunicator` (Class):
                - Handles wireless communication with the Main Control System (MCS).
                - Sends alerts and potentially heartbeats or status updates.
                - `void sendAlertToMCS(const AlertData& alert);`
                - `void establishConnection(const std::string& mcsAddress, int port);`
        3. Key C++ Libraries/Frameworks:
            - Networking: Boost.Asio or a similar library (e.g., cpp-httplib if REST is used, or ZeroMQ/gRPC for more complex messaging) for TCP/IP or UDP communication.
            - Concurrency: `std::thread` for background polling of probes, `std::mutex` for protecting shared data.
            - Configuration: A simple INI parser or JSON library (e.g., RapidJSON, nlohmann/json) for probe configurations.
            - Serialization: For `AlertData` (e.g., Protocol Buffers, JSON).

    B. Main Control System (MCS)
        1. Purpose: Central coordination unit. Receives alerts (including object detection alerts from the rover), displays system status, dispatches the rover, facilitates UI interaction, and logs all events.
        2. Core C++ Components:
            - `AlertHandler` (Class):
                - Receives `AlertData` from TMSCommunicator (server-side) and `DetectionAlertData` from the Rover Subsystem.
                - Validates and processes alerts.
                - Notifies the UI and `RoverDispatchController`.
                - `void processIncomingAlert(const AlertData& alert);`
                - `std::queue<AlertData> pendingAlerts;`
            - `RoverDispatchController` (Class):
                - Manages rover dispatch logic upon receiving a confirmed alert.
                - Communicates with the Rover Subsystem to send dispatch commands.
                - `void dispatchRoverToLocation(const Location& loc, const std::string& probeId);`
                - `RoverStatus getRoverStatus(const std::string& roverId);`
            - `EventLogger` (Singleton Class or Service):
                - Provides a centralized logging facility for all subsystems.
                - `void logEvent(LogLevel level, const std::string& source, const std::string& message);` // enum LogLevel { INFO, WARNING, ERROR, CRITICAL };
                - Supports different log outputs (file, console).
            - `MCSCommunicator` (Class):
                - Server component that listens for connections from TMS instances.
                - Receives messages from Rover Subsystem (status, camera feeds).
                - `void startServer(int port);`
                - `void handleTMSConnection(Socket& clientSocket);`
                - `void handleRoverConnection(Socket& clientSocket);`
        3. Key C++ Libraries/Frameworks:
            - Networking: Boost.Asio or similar for server-side networking.
            - Logging: Spdlog (highly recommended for its performance and flexibility), or Boost.Log.
            - Concurrency: `std::thread`, `std::condition_variable`, `std::atomic` for managing concurrent operations.
            - Data Structures: Standard Library containers (`std::map` for probeId-to-location, `std::vector`, `std::queue`).

    C. Rover Subsystem
        1. Purpose: Autonomous navigation to alert locations, on-rover Machine Learning (ML) for real-time object detection to aid inspection and navigation, manual control for inspection/repair, streaming camera feeds, and autonomous return.
        2. Core C++ Components (could be a standalone executable or library, potentially using ROS):
            - `NavigationController` (Class):
                - Implements autonomous navigation algorithms (e.g., A*, SLAM if environment is complex).
                - Interfaces with rover's motors and sensors (e.g., LIDAR, IMU).
                - Consumes detection data from `ObjectDetector` to refine navigation, identify targets, or avoid dynamic obstacles.
                - `void navigateTo(const Location& target);`
                - `void returnToHomeBase();`
                - `Location getCurrentLocation();`
                - `void incorporateDetectionData(const std::vector<DetectionResult>& detections);`
            - `ManualControlHandler` (Class):
                - Receives control commands from the MCS (via Rover Control Window).
                - Translates commands into motor/actuator actions.
                - `void processMovementCommand(const RoverMovementCommand& cmd);` // struct RoverMovementCommand { double linear_x, angular_z; };
                - `void processManipulatorCommand(const ManipulatorCommand& cmd);`
            - `CameraSystem` (Class):
                - Manages multiple camera feeds (navigation, arm, weld site).
                - Provides frames to the `ObjectDetector` for analysis.
                - Encodes and streams video data to MCS.
                - `void switchCameraView(const std::string& cameraName);`
                - `VideoFrame getCameraFeed(const std::string& cameraName);` // struct VideoFrame { std::vector<unsigned char> data; int width; int height; };
            - `RoverStateMachine` (Class):
                - Manages rover states: IDLE, AUTONOMOUS_NAVIGATION, OBJECT_DETECTION_ACTIVE, AWAITING_MANUAL_CONTROL, MANUAL_CONTROL, AUTONOMOUS_RETURN, ERROR.
                - `void transitionToState(RoverState newState);`
            - `RoverCommunicator` (Class):
                - Handles communication with MCS (sending status, video, summarized detection results/alerts; receiving commands).
                - `void sendDetectionAlert(const DetectionAlertData& detectionAlert);`
            - `ObjectDetector` (Class):
                - Purpose: Manages and executes ML models for real-time object detection using the rover's camera feeds.
                - `std::unique_ptr<InferenceEngineInterface> mlEngine;`
                - `std::string loadedModelName;`
                - `void loadModel(const std::string& modelPath, const ModelConfig& config);`
                - `std::vector<DetectionResult> detectObjects(const VideoFrame& frame);`
            - `DetectionResult` (struct):
                - Represents the result of an object detection.
                - `std::string object_id;`
                - `std::string label;`
                - `float confidence;`
                - `int roi_x, roi_y, roi_width, roi_height;`
                - `Location estimatedLocation;`
            - `DetectionAlertData` (struct):
                - Represents data for a detection alert.
                - `time_t timestamp;`
                - `std::string rover_id;`
                - `DetectionResult critical_detection;`
                - `std::string related_probe_id;`
        3. Key C++ Libraries/Frameworks:
            - Robotics: ROS (Robot Operating System) is a strong candidate if the rover is complex, providing navigation, SLAM, drivers, and inter-process communication. If not ROS, then custom C++ for motor control, sensor integration.
            - Computer Vision: OpenCV for image pre/post-processing for ML models and camera feed handling.
            - Networking: For video streaming (e.g., libraries supporting RTSP or WebRTC, or custom UDP streaming) and command/status/detection messages (Boost.Asio).
            - Math Libraries: Eigen for linear algebra if doing custom robotics calculations.
            - ML Inference Engines (C++ APIs): NVIDIA TensorRT (for NVIDIA Jetson), ONNX Runtime, TensorFlow Lite C++ API. Choose based on rover hardware and model requirements.
            - (Potentially) CUDA Libraries: If using NVIDIA GPUs directly for custom ML-related processing.
        4. Rover Hardware Considerations:
            - Onboard Compute: Requires a powerful Single-Board Computer (SBC) with GPU capabilities suitable for ML inference (e.g., NVIDIA Jetson series - Nano, Xavier NX, Orin).
            - Memory (RAM): Sufficient RAM (e.g., 8GB+) to hold ML models and process video data.
            - Storage: Fast SSD storage for OS, ML models, and logs.

    D. User Interface (UI) - Main Control System UI
        1. Purpose: Provides Data Window (sensor data, alerts, probe locations) and Rover Control Window (manual rover control, camera feeds, manipulation tools).
        2. Framework: Qt (C++)
        3. Core C++ Components (Qt-based):
            - `MainWindow` (inherits `QMainWindow`): Main application window, manages docking or MDI for Data and Rover Control windows.
            - `DataWindow` (inherits `QWidget` or `QDockWidget`):
                - `AlertsView` (inherits `QTableView`): Displays alerts table. Model (`QAbstractTableModel`) populated by `AlertHandler`.
                - `SensorDataView` (e.g., using Qt Charts or custom QGraphicsScene): Displays real-time sensor trends.
                - `ProbeLocationMap` (custom `QWidget` using `QGraphicsView`): Shows probe locations, highlights active alerts.
            - `RoverControlWindow` (inherits `QWidget` or `QDockWidget`):
                - `CameraFeedView` (e.g., `QLabel` updated with `QPixmap`, or `QOpenGLWidget` for direct rendering): Displays selected camera feed.
                - `RoverMovementControls` (custom `QWidget` with `QPushButtons`, `QSliders`): Sends commands to `ManualControlHandler` via MCS.
                - `ManipulatorControls` (custom `QWidget`): For rover arm.
            - `UIController` (Class):
                - Mediates communication between UI elements and MCS backend logic (e.g., `AlertHandler`, `RoverDispatchController`).
                - Uses Qt's signals and slots mechanism extensively.
                - `void onNewAlertReceived(const AlertData& alert);`
                - `void onRoverStatusUpdate(const RoverStatus& status);`
        4. Key C++ Libraries/Frameworks:
            - UI: Qt (Core, GUI, Widgets, Network, Multimedia for camera feeds, Charts).

III. Communication Protocols and Data Structures

    A. TMS <-> MCS:
        - Protocol: TCP/IP (reliable, ordered delivery for alerts).
        - Data Format: JSON or Protocol Buffers for `AlertData`.
        - Messages:
            - TMS to MCS: `ALERT_NOTIFICATION (AlertData)`, `HEARTBEAT (probeId, timestamp)`
            - MCS to TMS: `ACKNOWLEDGE_ALERT (alertId)` (optional)
    B. MCS <-> Rover Subsystem:
        - Protocol: TCP/IP for commands, status, and critical alerts. UDP or RTSP for video streams.
        - Data Format: JSON or Protocol Buffers for commands/status and detection data.
        - Messages:
            - MCS to Rover: `DISPATCH_COMMAND (targetLocation)`, `MANUAL_CONTROL_COMMAND (movement, armAction)`, `SWITCH_CAMERA (cameraName)`, `LOAD_ML_MODEL (modelName, modelPath_on_rover_or_url)` (optional)
            - Rover to MCS: `ROVER_STATUS (currentLocation, currentState, batteryLevel)`, `VIDEO_STREAM_DATA (...)`, `REPAIR_COMPLETE_NOTIFICATION`,
                           `DETECTION_ALERT (DetectionAlertData)`,
                           `DETECTION_SUMMARY (std::vector<DetectionResult>)`
        - Data Structures (Examples - to be defined more formally, e.g., in Protocol Buffers):
            - `struct DetectionResult { std::string object_id; std::string label; float confidence; int roi_x, roi_y, roi_width, roi_height; /* Optional: 3D location relative to rover */ };`
            - `struct DetectionAlertData { time_t timestamp; std::string rover_id; DetectionResult critical_detection; std::string related_probe_id; /* if applicable */ };`

IV. Build System and Dependencies Management
    A. Build System: CMake (standard for C++ projects).
    B. Dependency Management:
        - Git submodules or a package manager like Conan or vcpkg for external libraries.
    C. Key External Libraries (examples):
        - Boost (Asio, Log, Program_Options, Filesystem)
        - Qt (version 5.15+ or Qt 6+)
        - Spdlog
        - OpenCV (for Rover)
        - Eigen (for Rover, if custom math is needed)
        - JSON for Modern C++ (nlohmann/json) or RapidJSON
        - Google Protocol Buffers (if chosen for serialization)
        - Potentially ROS libraries if ROS is used for the rover.

V. Error Handling and Safety-Critical Considerations
    A. Exception Handling: Use `try-catch` blocks for operations that can fail (I/O, network, resource allocation). Define custom exception classes derived from `std::exception`.
    B. Return Codes: For internal functions where exceptions might be too heavy or for API boundaries where error codes are conventional.
    C. Input Validation: Rigorously validate all data received from external sources (TMS, Rover, UI inputs).
    D. Resource Management: Strict adherence to RAII (Resource Acquisition Is Initialization) using smart pointers (`std::unique_ptr`, `std::shared_ptr`) and custom RAII wrappers for file handles, sockets, locks, etc.
    E. Fail-Safes:
        - Rover: Emergency stop functionality, transition to a safe state on communication loss or critical sensor failure.
        - MCS: Graceful degradation if a non-critical component fails.
    F. Logging: Comprehensive and categorized logging of errors, warnings, and critical events.
    G. State Machines: Use well-defined state machines for complex components like the Rover to ensure predictable behavior and transitions.
    H. Timeouts: Implement timeouts for all blocking network operations and inter-process communication.

VI. Modularity and Interfaces
    A. Each major component (TMS, MCS Core, Rover Subsystem, UI) should be buildable as a separate library or executable where appropriate.
    B. Define abstract base classes or pure virtual interfaces for key interactions. Example:
        ```cpp
        // IAlertNotifier.h - Implemented by UI, used by AlertHandler
        class IAlertNotifier {
        public:
            virtual ~IAlertNotifier() = default;
            virtual void notifyNewAlert(const AlertData& alert) = 0;
        };

        // IRoverController.h - Implemented by Rover Subsystem, used by MCS
        class IRoverController {
        public:
            virtual ~IRoverController() = default;
            virtual bool dispatchTo(const Location& target) = 0;
            virtual bool sendManualCommand(const RoverMovementCommand& cmd) = 0;
            virtual RoverStatus getCurrentStatus() = 0;
        };
        ```
    C. Message-based communication APIs where direct linking is not feasible (e.g., between separate processes like MCS and Rover).

VII. Future Considerations
    A. Redundancy: For critical components like communication links or main control processors.
    B. Security: Authentication and encryption for wireless communication.
    C. Simulation Mode: For testing and development without actual hardware.
    D. Scalability: Design to potentially handle more probes or rovers in the future.
    E. Machine Learning Workflow:
        1. Model Training: Typically performed offline using Python-based frameworks (e.g., TensorFlow, PyTorch, YOLO) on dedicated development/training servers with larger datasets.
        2. Model Conversion & Optimization: Trained models are converted to formats compatible with C++ inference engines (e.g., ONNX, TensorRT engine files, TensorFlow Lite models) and optimized for the target rover hardware.
        3. Model Deployment: Optimized models are deployed to the rover's storage for loading by the `ObjectDetector`. The MCS might facilitate or manage this deployment process.
        4. On-Rover Inference: The `ObjectDetector` (C++) loads the model and performs real-time inference on camera feeds.
        5. Feedback Loop: (Optional) Misclassifications or new scenarios identified by the rover can be used to collect new data to retrain and improve models. 